use std::collections::HashMap;
use std::hash::{Hash, Hasher};
use std::rc::Rc;
use salsa::InternId;
use crate::{impl_intern_key, query_error};
use crate::language::{Ident, im, ImmutableString};
use crate::language::analysis::error::{AnalysisError, QueryResult};
use crate::language::analysis::event::EventQuery;
use crate::language::analysis::interner::{Interner, IntoInternId};
use crate::language::analysis::r#enum::EnumQuery;
use crate::language::analysis::r#type::TypeQuery;
use crate::language::ast::EventDeclaration;
use crate::language::im::{EnumConstant, EnumConstantId, EnumDeclarationId, EnumDefinition, EventDeclarationId, RValue, StructDeclarationId};

#[salsa::query_group(NamespaceDatabase)]
pub trait NamespaceQuery: TypeQuery + EnumQuery {

    fn query_root_namespace(&self) -> Result<NamespaceId, AnalysisError>;

    fn query_enum_namespace(&self, r#enum: EnumDeclarationId) -> QueryResult<NamespaceId, AnalysisError>;

    fn query_event_namespace(
        &self,
        event_decl: EventDeclarationId
    ) -> Result<NamespaceId, AnalysisError>;

    fn query_struct_namespace(
        &self,
        struct_decl: StructDeclarationId
    ) -> Result<NamespaceId, AnalysisError>;

    fn query_namespaced_rvalue(
        &self,
        nameholders: Vec<Nameholder>,
        ident: Ident,
    ) -> QueryResult<RValue, AnalysisError>;

    fn query_namespace(
        &self,
        nameholders: Vec<Nameholder>
    ) -> QueryResult<Rc<Namespace>, AnalysisError>;

    fn query_namespaced_type(
        &self,
        nameholders: Vec<Nameholder>,
        ident: Ident,
    ) -> QueryResult<im::Type, AnalysisError>;

    fn query_namespaced_event(
        &self,
        nameholders: Vec<Nameholder>,
        ident: Ident,
    ) -> QueryResult<EventDeclarationId, AnalysisError>;
}

fn query_root_namespace(db: &dyn NamespaceQuery) -> Result<NamespaceId, AnalysisError> {
    let mut namespace = Namespace::new();

    for (ident, r#type) in db.query_type_map() {
        namespace.add(ident, RValue::Type(r#type), db)?;
    }

    Ok(Rc::new(namespace).intern(db))
}

fn query_enum_namespace(db: &dyn NamespaceQuery, r#enum: EnumDeclarationId) -> QueryResult<NamespaceId, AnalysisError> {
    db.query_enum_def(r#enum)
        .map(|r#enum| Rc::new(Namespace::from_enum_definition(db, r#enum.definition)))
        .intern(db)
}

fn query_event_namespace(db: &dyn NamespaceQuery, event_decl: EventDeclarationId) -> Result<NamespaceId, AnalysisError> {
    todo!()
}

fn query_struct_namespace(_db: &dyn NamespaceQuery, _struct_decl: StructDeclarationId) -> Result<NamespaceId, AnalysisError> {
    todo!()
}

fn query_namespaced_rvalue(db: &dyn NamespaceQuery, nameholders: Vec<Nameholder>, ident: Ident) -> QueryResult<RValue, AnalysisError> {
    db.query_namespace(nameholders)
        .flat_map(|namespace| {
            namespace.get(&ident).ok_or(AnalysisError::CannotFindIdent(ident)).into()
        })
}

fn query_namespace(db: &dyn NamespaceQuery, nameholders: Vec<Nameholder>) -> QueryResult<Rc<Namespace>, AnalysisError> {
    nameholders.into_iter()
        .map(|nameholder| {
            match nameholder {
                Nameholder::Root => db.query_root_namespace().into(),
                Nameholder::Enum(enum_placeholder) => match enum_placeholder {
                    // TODO Current match should return the enum constant id and not the namespace id
                    EnumNameholder::ByEnum(enum_decl) => db.query_enum_namespace(enum_decl),
                    EnumNameholder::ByConstant(enum_constant_id) => {
                        // Clion cannot verify functions generated by proc macros
                        // TODO Add this maybe to every lookup method
                        let enum_constant: EnumConstant = db.lookup_intern_enum_constant(enum_constant_id);
                        db.query_enum_namespace(enum_constant.r#enum)
                    }
                },
                Nameholder::Struct(struct_decl) => db.query_struct_namespace(struct_decl).into(),
                Nameholder::Event(event_decl) => db.query_event_namespace(event_decl).into(),
                Nameholder::Empty => QueryResult::Ok(db.intern_namespace(Rc::new(Namespace::new())))
            }
        })
        .collect::<QueryResult<_, _>>()
        .fold(
            Rc::new(Namespace::new()),
            |acc, item| {
                let namespace: Rc<Namespace> = db.lookup_intern_namespace(item);
                // TODO Do we really need to clone here?
                let mut namespace = (*namespace).clone();
                namespace.parent.push(acc);
                QueryResult::Ok(Rc::new(namespace))
            })
}

fn query_namespaced_type(
    db: &dyn NamespaceQuery,
    nameholders: Vec<Nameholder>,
    ident: Ident,
) -> QueryResult<im::Type, AnalysisError> {
    db.query_namespaced_rvalue(nameholders, ident)
        .flat_map(|rvalue| match rvalue {
            RValue::Type(r#type) => QueryResult::Ok(r#type),
            RValue::EnumConstant(_) => AnalysisError::WrongType.into()

        })
}

fn query_namespaced_event(
    db: &dyn NamespaceQuery,
    nameholders: Vec<Nameholder>,
    ident: Ident,
) -> QueryResult<EventDeclarationId, AnalysisError> {
    db.query_namespaced_type(nameholders, ident)
        .flat_map(|r#type| match r#type {
            im::Type::Event(event) => QueryResult::Ok(event),
            im::Type::Enum(_) | im::Type::Struct(_) | im::Type::Unit => {
                QueryResult::Err(vec![AnalysisError::WrongType])
            }
        })
}

/// Placeholder for [Namespace].
/// The name is a combination of **Name**space and Place**holder**
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Nameholder {
    Root,
    Empty,
    Enum(EnumNameholder),
    Struct(StructDeclarationId),
    Event(EventDeclarationId),
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum EnumNameholder {
    ByEnum(EnumDeclarationId),
    ByConstant(EnumConstantId),
}

impl Into<Nameholder> for EnumNameholder {
    fn into(self) -> Nameholder {
        Nameholder::Enum(self)
    }
}

#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]
pub struct NamespaceId(InternId);

impl_intern_key!(NamespaceId);

#[derive(Clone, Debug, Eq)]
pub struct Namespace {
    parent: Vec<Rc<Namespace>>,
    map: HashMap<ImmutableString, RValue>,
}

impl Namespace {

    fn new() -> Namespace {
        Namespace { map: HashMap::new(), parent: Vec::new() }
    }

    pub fn from_enum_definition(db: &(impl Interner + ?Sized), definition: EnumDefinition) -> Namespace {
        let map = definition.constants.into_iter()
            .map::<(_, EnumConstant), _>(|enum_constant_id| (
                enum_constant_id,
                db.lookup_intern_enum_constant(enum_constant_id)
            ))
            .map(|it| (it.1.name.value.clone(), RValue::EnumConstant(it.0)))
            .collect();
        Namespace { parent: Vec::new(), map }
    }

    fn add<I: Interner + ?Sized>(&mut self, ident: Ident, rvalue: RValue, db: &I) -> Result<(), AnalysisError> {
        match self.contains(&ident) {
            Some(root) => {
                AnalysisError::DuplicateIdent {
                    first: root.name(db), // TODO How to deal with errors?
                    second: ident,
                }.into()
            }
            None => {
                self.map.insert(ident.value.clone(), rvalue);
                Ok(())
            }
        }
    }

    fn get(&self, ident: &Ident) -> Option<RValue> {
        self.map.get(&ident.value).map(|it| it.clone())
    }

    fn contains(&self, ident: &Ident) -> Option<RValue> {
        let option = self.map.get(&ident.value).map(|it| it.clone());
        if option.is_some() {
            option
        } else {
            self.parent.iter()
                .map(|it| it.contains(&ident))
                .filter(|it| it.is_some())
                .flatten()
                .collect::<Vec<_>>()
                .pop()
        }
    }

    fn sorted_map_entries(&self) -> Vec<(&ImmutableString, &RValue)> {
        let mut content = self.map.iter().collect::<Vec<_>>();
        content.sort_by_key(|it| it.0);
        content
    }
}

impl PartialEq for Namespace {
    fn eq(&self, other: &Self) -> bool {
        self.parent == other.parent && self.sorted_map_entries() == other.sorted_map_entries()
    }
}

impl Hash for Namespace {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.parent.hash(state);
        self.sorted_map_entries().hash(state)
    }
}

impl IntoInternId for Rc<Namespace> {
    type Interned = NamespaceId;

    fn intern<T: Interner + ?Sized>(self, db: &T) -> NamespaceId {
        db.intern_namespace(self)
    }
}
