use std::collections::HashMap;
use std::hash::{Hash, Hasher};
use std::rc::Rc;
use salsa::InternId;
use crate::{impl_intern_key, query_error};
use crate::language::{Ident, im, ImmutableString};
use crate::language::analysis::error::{AnalysisError, QueryResult};
use crate::language::analysis::interner::{Interner, IntoInternId};
use crate::language::analysis::r#enum::EnumQuery;
use crate::language::analysis::r#type::TypeQuery;
use crate::language::im::{EnumConstant, EnumConstantId, EnumDeclarationId, EnumDefinition, EventDeclarationId, RValue, StructDeclarationId};

#[salsa::query_group(NamespaceDatabase)]
pub trait NamespaceQuery: TypeQuery + EnumQuery {

    fn query_root_namespace(&self) -> Result<NamespaceId, AnalysisError>;

    fn query_enum_namespace(&self, r#enum: EnumDeclarationId) -> QueryResult<NamespaceId, AnalysisError>;

    fn query_event_namespace(
        &self,
        event_decl: EventDeclarationId
    ) -> Result<NamespaceId, AnalysisError>;

    fn query_struct_namespace(
        &self,
        struct_decl: StructDeclarationId
    ) -> Result<NamespaceId, AnalysisError>;

    fn query_namespaced_rvalue(
        &self,
        namespace_placeholder: NamespacePlaceholder,
        ident: Ident
    ) -> QueryResult<RValue, AnalysisError>;

    fn query_namespaced_type(
        &self,
        namespace_placeholder: NamespacePlaceholder,
        ident: Ident
    ) -> QueryResult<im::Type, AnalysisError>;

    fn query_namespaced_event(
        &self,
        namespace_placeholder: NamespacePlaceholder,
        ident: Ident
    ) -> QueryResult<EventDeclarationId, AnalysisError>;
}

fn query_namespaced_event(
    db: &dyn NamespaceQuery,
    namespace_placeholder: NamespacePlaceholder,
    ident: Ident
) -> QueryResult<EventDeclarationId, AnalysisError> {
    db.query_namespaced_type(namespace_placeholder, ident)
        .flat_map(|r#type| match r#type {
            im::Type::Event(event) => QueryResult::Ok(event),
            im::Type::Enum(_) | im::Type::Struct(_) | im::Type::Unit => {
                QueryResult::Err(vec![AnalysisError::WrongType])
            }
        })
}

fn query_namespaced_type(
    db: &dyn NamespaceQuery,
    namespace_placeholder: NamespacePlaceholder,
    ident: Ident
) -> QueryResult<im::Type, AnalysisError> {
    db.query_namespaced_rvalue(namespace_placeholder, ident)
        .flat_map(|rvalue| match rvalue {
            RValue::Type(r#type) => QueryResult::Ok(r#type),
            RValue::EnumConstant(_) => AnalysisError::WrongType.into()
        })
}

fn query_root_namespace(db: &dyn NamespaceQuery) -> Result<NamespaceId, AnalysisError> {
    let mut namespace = Namespace::new_root();

    for (ident, r#type) in db.query_type_map() {
        namespace.add(ident, RValue::Type(r#type), db)?;
    }

    Ok(Rc::new(namespace).intern(db))
}

fn query_enum_namespace(db: &dyn NamespaceQuery, r#enum: EnumDeclarationId) -> QueryResult<NamespaceId, AnalysisError> {
    db.query_enum_def(r#enum)
        .map(|r#enum| Rc::new(Namespace::from_enum_definition(db, r#enum.definition)))
        .intern(db)
}

fn query_event_namespace(_db: &dyn NamespaceQuery, _event_decl: EventDeclarationId) -> Result<NamespaceId, AnalysisError> {
    todo!()
}

fn query_struct_namespace(_db: &dyn NamespaceQuery, _struct_decl: StructDeclarationId) -> Result<NamespaceId, AnalysisError> {
    todo!()
}

fn query_namespaced_rvalue(db: &dyn NamespaceQuery, namespace_placeholder: NamespacePlaceholder, ident: Ident) -> QueryResult<RValue, AnalysisError> {
    QueryResult::empty()
        .flat_map(|_| {
            let namespace: QueryResult<_, _> = match namespace_placeholder {
                NamespacePlaceholder::Root => db.query_root_namespace().into(),
                NamespacePlaceholder::Enum(enum_placeholder) => match enum_placeholder {
                    // TODO Current match should return the enum constant id and not the namespace id
                    EnumPlaceholder::ByEnum(enum_decl) => db.query_enum_namespace(enum_decl),
                    EnumPlaceholder::ByConstant(enum_constant_id) => {
                        // Clion cannot verify functions generated by proc macros
                        // TODO Add this maybe to every lookup method?
                        let enum_constant: EnumConstant = db.lookup_intern_enum_constant(enum_constant_id);
                        db.query_enum_namespace(enum_constant.r#enum)
                    }
                },
                NamespacePlaceholder::Struct(struct_decl) => db.query_struct_namespace(struct_decl).into(),
                NamespacePlaceholder::Event(event_decl) => db.query_event_namespace(event_decl).into(),
                NamespacePlaceholder::Empty => query_error!(AnalysisError::CannotFindIdent(ident.clone()))
            };
            namespace
        })
        .flat_map(|namespace_id| {
            let namespace: Rc<Namespace> = db.lookup_intern_namespace(namespace_id);
            namespace.get(&ident).ok_or(AnalysisError::CannotFindIdent(ident)).into()
        })
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NamespacePlaceholder {
    Root,
    Empty,
    Enum(EnumPlaceholder),
    Struct(StructDeclarationId),
    Event(EventDeclarationId)
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum EnumPlaceholder {
    ByEnum(EnumDeclarationId),
    ByConstant(EnumConstantId)
}

impl Into<NamespacePlaceholder> for EnumPlaceholder {
    fn into(self) -> NamespacePlaceholder {
        NamespacePlaceholder::Enum(self)
    }
}

pub struct NamespaceProvider;

impl NamespaceProvider {

    pub fn get(&self) -> Rc<Namespace> {
        todo!()
    }
}

#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]
pub struct NamespaceId(InternId);

impl_intern_key!(NamespaceId);

#[derive(Debug, Eq)]
pub struct Namespace {
    parent: Vec<Rc<Namespace>>,
    map: HashMap<ImmutableString, RValue>,
}


impl Namespace {
    pub fn from_enum_definition(db: &(impl Interner + ?Sized), definition: EnumDefinition) -> Namespace {
        let map = definition.constants.into_iter()
            .map::<(_, EnumConstant), _>(|enum_constant_id| (
                enum_constant_id,
                db.lookup_intern_enum_constant(enum_constant_id)
            ))
            .map(|it| (it.1.name.value.clone(), RValue::EnumConstant(it.0)))
            .collect();
        Namespace { parent: Vec::new(), map }
    }

    fn sorted_map_entries(&self) -> Vec<(&ImmutableString, &RValue)> {
        let mut content = self.map.iter().collect::<Vec<_>>();
        content.sort_by_key(|it| it.0);
        content
    }
}

impl PartialEq for Namespace {
    fn eq(&self, other: &Self) -> bool {
        self.parent == other.parent && self.sorted_map_entries() == other.sorted_map_entries()
    }
}

impl Hash for Namespace {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.parent.hash(state);
        self.sorted_map_entries().hash(state)
    }
}

impl IntoInternId for Rc<Namespace> {
    type Interned = NamespaceId;

    fn intern<T: Interner + ?Sized>(self, db: &T) -> NamespaceId {
        db.intern_namespace(self)
    }
}

impl Namespace {
    fn new_root() -> Namespace {
        Namespace { map: HashMap::new(), parent: Vec::new() }
    }

    fn add<I: Interner + ?Sized>(&mut self, ident: Ident, rvalue: RValue, db: &I) -> Result<(), AnalysisError> {
        match self.contains(&ident) {
            Some(root) => {
                AnalysisError::DuplicateIdent {
                    first: root.name(db), // TODO How to deal with errors?
                    second: ident
                }.into()
            }
            None => {
                self.map.insert(ident.value.clone(), rvalue);
                Ok(())
            }
        }
    }

    fn get(&self, ident: &Ident) -> Option<RValue> {
        self.map.get(&ident.value).map(|it| it.clone())
    }

    fn contains(&self, ident: &Ident) -> Option<RValue> {
        let option = self.map.get(&ident.value).map(|it| it.clone());
        if option.is_some() {
            option
        } else {
            self.parent.iter()
                .map(|it| it.contains(&ident))
                .filter(|it| it.is_some())
                .flatten()
                .collect::<Vec<_>>()
                .pop()
        }
    }
}
